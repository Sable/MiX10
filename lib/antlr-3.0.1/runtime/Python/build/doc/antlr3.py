""" @package antlr3
@brief ANTLR3 runtime package

This module contains all support classes, which are needed to use recognizers
generated by ANTLR3.

@mainpage

\note Please be warned that the line numbers in the API documentation do not
match the real locations in the source code of the package. This is an
unintended artifact of doxygen, which I could only convince to use the
correct module names by concatenating all files from the package into a single
module file...

Here is a little overview over the most commonly used classes provided by
this runtime:

@section recognizers Recognizers

These recognizers are baseclasses for the code which is generated by ANTLR3.

- BaseRecognizer: Base class with common recognizer functionality.
- Lexer: Base class for lexers.
- Parser: Base class for parsers.
- tree.TreeParser: Base class for %tree parser.

@section streams Streams

Each recognizer pulls its input from one of the stream classes below. Streams
handle stuff like buffering, look-ahead and seeking.

A character stream is usually the first element in the pipeline of a typical
ANTLR3 application. It is used as the input for a Lexer.

- ANTLRStringStream: Reads from a string objects. The input should be a unicode
  object, or ANTLR3 will have trouble decoding non-ascii data.
- ANTLRFileStream: Opens a file and read the contents, with optional character
  decoding.
- ANTLRInputStream: Reads the date from a file-like object, with optional
  character decoding.

A Parser needs a TokenStream as input (which in turn is usually fed by a
Lexer):

- CommonTokenStream: A basic and most commonly used TokenStream
  implementation.
- TokenRewriteStream: A modification of CommonTokenStream that allows the
  stream to be altered (by the Parser). See the 'tweak' example for a usecase.

And tree.TreeParser finally fetches its input from a tree.TreeNodeStream:

- tree.CommonTreeNodeStream: A basic and most commonly used tree.TreeNodeStream
  implementation.
  

@section tokenstrees Tokens and Trees

A Lexer emits Token objects which are usually buffered by a TokenStream. A
Parser can build a Tree, if the output=AST option has been set in the grammar.

The runtime provides these Token implementations:

- CommonToken: A basic and most commonly used Token implementation.
- ClassicToken: A Token object as used in ANTLR 2.x, used to %tree
  construction.

Tree objects are wrapper for Token objects.

- tree.CommonTree: A basic and most commonly used Tree implementation.

A tree.TreeAdaptor is used by the parser to create tree.Tree objects for the
input Token objects.

- tree.CommonTreeAdaptor: A basic and most commonly used tree.TreeAdaptor
implementation.


@section Exceptions

RecognitionException are generated, when a recognizer encounters incorrect
or unexpected input.

- RecognitionException
  - MismatchedRangeException
  - MismatchedSetException
    - MismatchedNotSetException
    .
  - MismatchedTokenException
  - MismatchedTreeNodeException
  - NoViableAltException
  - EarlyExitException
  - FailedPredicateException
  .
.

A tree.RewriteCardinalityException is raised, when the parsers hits a
cardinality mismatch during AST construction. Although this is basically a
bug in your grammar, it can only be detected at runtime.

- tree.RewriteCardinalityException
  - tree.RewriteEarlyExitException
  - tree.RewriteEmptyStreamException
  .
.

"""

# tree.RewriteRuleElementStream
# tree.RewriteRuleSubtreeStream
# tree.RewriteRuleTokenStream
# CharStream
# DFA
# TokenSource

# [The "BSD licence"]
# Copyright (c) 2005-2006 Terence Parr
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

from constants import *
from dfa import *
from exceptions import *
from recognizers import *
from streams import *
from tokens import *
"""ANTLR3 exception hierarchy"""



class RecognitionException(Exception):
    """@brief The root of the ANTLR exception hierarchy.

    To avoid English-only error messages and to generally make things
    as flexible as possible, these exceptions are not created with strings,
    but rather the information necessary to generate an error.  Then
    the various reporting methods in Parser and Lexer can be overridden
    to generate a localized error message.  For example, MismatchedToken
    exceptions are built with the expected token type.
    So, don't expect getMessage() to return anything.

    Note that as of Java 1.4, you can access the stack trace, which means
    that you can compute the complete trace of rules from the start symbol.
    This gives you considerable context information with which to generate
    useful error messages.

    ANTLR generates code that throws exceptions upon recognition error and
    also generates code to catch these exceptions in each rule.  If you
    want to quit upon first error, you can turn off the automatic error
    handling mechanism using rulecatch action, but you still need to
    override methods mismatch and recoverFromMismatchSet.
    
    In general, the recognition exceptions can track where in a grammar a
    problem occurred and/or what was the expected input.  While the parser
    knows its state (such as current input symbol and line info) that
    state can change before the exception is reported so current token index
    is computed and stored at exception time.  From this info, you can
    perhaps print an entire line of input not just a single token, for example.
    Better to just say the recognizer had a problem and then let the parser
    figure out a fancy report.
    
    """

    def __init__(self, input=None):
        Exception.__init__(self)

	# What input stream did the error occur in?
        self.input = None

        # What is index of token/char were we looking at when the error
        # occurred?
        self.index = None

	# The current Token when an error occurred.  Since not all streams
	# can retrieve the ith Token, we have to track the Token object.
	# For parsers.  Even when it's a tree parser, token might be set.
        self.token = None

	# If this is a tree parser exception, node is set to the node with
	# the problem.
        self.node = None

	# The current char when an error occurred. For lexers.
        self.c = None

	# Track the line at which the error occurred in case this is
	# generated from a lexer.  We need to track this since the
        # unexpected char doesn't carry the line info.
        self.line = None

        self.charPositionInLine = None


        if input is not None:
            self.input = input
            self.index = input.index()

            # late import to avoid cyclic dependencies
            from antlr3.streams import TokenStream, CharStream
            from antlr3.tree import CommonTreeNodeStream, CommonTree

            if isinstance(self.input, TokenStream):
                self.token = self.input.LT(1)
                self.line = self.token.line
                self.charPositionInLine = self.token.charPositionInLine

            if isinstance(self.input, CommonTreeNodeStream):
                self.node = self.input.LT(1)
                if isinstance(self.node, CommonTree):
                    self.token = self.node.token
                    self.line = self.token.line
                    self.charPositionInLine = self.token.charPositionInLine

            else:
                if isinstance(self.input, CharStream):
                    self.c = self.input.LA(1)
                    self.line = self.input.line
                    self.charPositionInLine = self.input.charPositionInLine

                else:
                    self.c = self.input.LA(1)


    def getUnexpectedType(self):
        """Return the token type or char of the unexpected input element"""

        try:
            return self.token.type
        except AttributeError:
            return self.c

    unexpectedType = property(getUnexpectedType)
    

class MismatchedTokenException(RecognitionException):
    """@brief The next token does not match the expected type."""
    
    def __init__(self, expecting, input):
        RecognitionException.__init__(self, input)
        self.expecting = expecting
        

    def __str__(self):
        #return "MismatchedTokenException("+self.expecting+")"
        return "MismatchedTokenException(%r!=%r)" % (
            self.getUnexpectedType(), self.expecting
            )
    __repr__ = __str__
    

class MismatchedRangeException(RecognitionException):
    """@brief The next token does not match a range of expected types."""

    def __init__(self, a, b, input):
        RecognitionException.__init__(self, input)

        self.a = a
        self.b = b
        

    def __str__(self):
        return "MismatchedRangeException(%r not in [%r..%r])" % (
            self.getUnexpectedType(), self.a, self.b
            )
    __repr__ = __str__
    

class MismatchedSetException(RecognitionException):
    """@brief The next token does not match a set of expected types."""

    def __init__(self, expecting, input):
        RecognitionException.__init__(self, input)

        self.expecting = expecting
        

    def __str__(self):
        return "MismatchedSetException(%r not in %r)" % (
            self.getUnexpectedType(), self.expecting
            )
    __repr__ = __str__


class MismatchedNotSetException(MismatchedSetException):
    """@brief Used for remote debugger deserialization"""
    
    def __str__(self):
        return "MismatchedNotSetException(%r!=%r)" % (
            self.getUnexpectedType(), self.expecting
            )
    __repr__ = __str__


class NoViableAltException(RecognitionException):
    """@brief Unable to decide which alternative to choose."""

    def __init__(
        self, grammarDecisionDescription, decisionNumber, stateNumber, input
        ):
        RecognitionException.__init__(self, input)

        self.grammarDecisionDescription = grammarDecisionDescription
        self.decisionNumber = decisionNumber
        self.stateNumber = stateNumber


    def __str__(self):
        return "NoViableAltException(%r!=[%r])" % (
            self.unexpectedType, self.grammarDecisionDescription
            )
    __repr__ = __str__
    

class EarlyExitException(RecognitionException):
    """@brief The recognizer did not match anything for a (..)+ loop."""

    def __init__(self, decisionNumber, input):
        RecognitionException.__init__(self, input)

        self.decisionNumber = decisionNumber


class FailedPredicateException(RecognitionException):
    """@brief A semantic predicate failed during validation.

    Validation of predicates
    occurs when normally parsing the alternative just like matching a token.
    Disambiguating predicate evaluation occurs when we hoist a predicate into
    a prediction decision.
    """

    def __init__(self, input, ruleName, predicateText):
        RecognitionException.__init__(self, input)
        
        self.ruleName = ruleName
        self.predicateText = predicateText


    def __str__(self):
        return "FailedPredicateException("+self.ruleName+",{"+self.predicateText+"}?)"


class MismatchedTreeNodeException(RecognitionException):
    """@brief The next tree mode does not match the expected type."""

    def __init__(self, expecting, input):
        RecognitionException.__init__(self, input)

        t = input.LT(1)
        from antlr3.tree import Tree
        if isinstance(input.LT(1), Tree):
            self.line = t.line
            self.charPositionInLine = t.charPositionInLine
            # TODO: if DOWN/UP, there is no line info currently
        
        self.expecting = expecting

    def __str__(self):
        return "MismatchedTreeNodeException(%r!=%r)" % (
            self.getUnexpectedType(), self.expecting
            )
    __repr__ = __str__
"""ANTLR3 runtime package"""


EOF = -1

## All tokens go to the parser (unless skip() is called in that rule)
# on a particular "channel".  The parser tunes to a particular channel
# so that whitespace etc... can go to the parser on a "hidden" channel.
DEFAULT_CHANNEL = 0

## Anything on different channel than DEFAULT_CHANNEL is not parsed
# by parser.
HIDDEN_CHANNEL = 99

# Predefined token types
EOR_TOKEN_TYPE = 1

##
# imaginary tree navigation type; traverse "get child" link
DOWN = 2
##
#imaginary tree navigation type; finish with a child list
UP = 3

MIN_TOKEN_TYPE = UP+1
	
INVALID_TOKEN_TYPE = 0

"""ANTLR3 runtime package"""

"""ANTLR3 runtime package"""


from antlr3.constants import EOF, DEFAULT_CHANNEL, INVALID_TOKEN_TYPE

############################################################################
#
# basic token interface
#
############################################################################

class Token(object):
    """@brief Abstract token baseclass."""

    def getText(self):
        """@brief Get the text of the token.

        Using setter/getter methods is deprecated. Use o.text instead.
        """
        raise NotImplementedError
    
    def setText(self, text):
        """@brief Set the text of the token.

        Using setter/getter methods is deprecated. Use o.text instead.
        """
        raise NotImplementedError


    def getType(self):
        """@brief Get the type of the token.

        Using setter/getter methods is deprecated. Use o.type instead."""

        raise NotImplementedError
    
    def setType(self, ttype):
        """@brief Get the type of the token.

        Using setter/getter methods is deprecated. Use o.type instead."""

        raise NotImplementedError
    
    
    def getLine(self):
        """@brief Get the line number on which this token was matched

        Lines are numbered 1..n
        
        Using setter/getter methods is deprecated. Use o.line instead."""

        raise NotImplementedError
    
    def setLine(self, line):
        """@brief Set the line number on which this token was matched

        Using setter/getter methods is deprecated. Use o.line instead."""

        raise NotImplementedError
    
    
    def getCharPositionInLine(self):
        """@brief Get the column of the tokens first character,
        
        Columns are numbered 0..n-1
        
        Using setter/getter methods is deprecated. Use o.charPositionInLine instead."""

        raise NotImplementedError
    
    def setCharPositionInLine(self, pos):
        """@brief Set the column of the tokens first character,

        Using setter/getter methods is deprecated. Use o.charPositionInLine instead."""

        raise NotImplementedError
    

    def getChannel(self):
        """@brief Get the channel of the token

        Using setter/getter methods is deprecated. Use o.channel instead."""

        raise NotImplementedError
    
    def setChannel(self, channel):
        """@brief Set the channel of the token

        Using setter/getter methods is deprecated. Use o.channel instead."""

        raise NotImplementedError
    


    def getTokenIndex(self):
        """@brief Get the index in the input stream.

        An index from 0..n-1 of the token object in the input stream.
        This must be valid in order to use the ANTLRWorks debugger.
        
        Using setter/getter methods is deprecated. Use o.index instead."""

        raise NotImplementedError
    
    def setTokenIndex(self, index):
        """@brief Set the index in the input stream.

        Using setter/getter methods is deprecated. Use o.index instead."""

        raise NotImplementedError


############################################################################
#
# token implementations
#
# Token
# +- CommonToken
# \- ClassicToken
#
############################################################################

class CommonToken(Token):
    """@brief Basic token implementation.

    This implementation does not copy the text from the input stream upon
    creation, but keeps start/stop pointers into the stream to avoid
    unnecessary copy operations.

    """
    
    def __init__(self, type=None, channel=DEFAULT_CHANNEL, text=None,
                 input=None, start=None, stop=None, oldToken=None):
        Token.__init__(self)
        
        if oldToken is not None:
            self.type = oldToken.type
            self.line = oldToken.line
            self.charPositionInLine = oldToken.charPositionInLine
            self.channel = oldToken.channel
            self.index = oldToken.index
            self._text = oldToken._text
            self.input = oldToken.input
            self.start = oldToken.start
            self.stop = oldToken.stop
            
        else:
            self.type = type
            self.input = input
            self.charPositionInLine = -1 # set to invalid position
            self.line = 0
            self.channel = channel
            
	    #What token number is this from 0..n-1 tokens; < 0 implies invalid index
            self.index = -1
            
            # We need to be able to change the text once in a while.  If
            # this is non-null, then getText should return this.  Note that
            # start/stop are not affected by changing this.
            self._text = text

            # The char position into the input buffer where this token starts
            self.start = start

            # The char position into the input buffer where this token stops
            # This is the index of the last char, *not* the index after it!
            self.stop = stop


    def getText(self):
        if self._text is not None:
            return self._text

        if self.input is None:
            return None
        
        return self.input.substring(self.start, self.stop)


    def setText(self, text):
        """
        Override the text for this token.  getText() will return this text
        rather than pulling from the buffer.  Note that this does not mean
        that start/stop indexes are not valid.  It means that that input
        was converted to a new string in the token object.
	"""
        self._text = text

    text = property(getText, setText)


    def getType(self):
        return self.type 

    def setType(self, ttype):
        self.type = ttype

    
    def getLine(self):
        return self.line
    
    def setLine(self, line):
        self.line = line


    def getCharPositionInLine(self):
        return self.charPositionInLine
    
    def setCharPositionInLine(self, pos):
        self.charPositionInLine = pos


    def getChannel(self):
        return self.channel
    
    def setChannel(self, channel):
        self.channel = channel
    

    def getTokenIndex(self):
        return self.index
    
    def setTokenIndex(self, index):
        self.index = index


    def __str__(self):
        channelStr = ""
        if self.channel > 0:
            channelStr = ",channel=" + str(self.channel)

        txt = self.text
        if txt is not None:
            txt = txt.replace("\n","\\\\n")
            txt = txt.replace("\r","\\\\r")
            txt = txt.replace("\t","\\\\t")
        else:
            txt = "<no text>"

        return "[@%s,%s:%s=%r,<%s>%s,%s:%s]" % (
            self.index,
            self.start, self.stop,
            txt,
            self.type, channelStr,
            self.line, self.charPositionInLine
            )
    

class ClassicToken(Token):
    """@brief Alternative token implementation.
    
    A Token object like we'd use in ANTLR 2.x; has an actual string created
    and associated with this object.  These objects are needed for imaginary
    tree nodes that have payload objects.  We need to create a Token object
    that has a string; the tree node will point at this token.  CommonToken
    has indexes into a char stream and hence cannot be used to introduce
    new strings.
    """

    def __init__(self, type=None, text=None, channel=DEFAULT_CHANNEL,
                 oldToken=None
                 ):
        Token.__init__(self)
        
        if oldToken is not None:
            self.text = oldToken.text
            self.type = oldToken.type
            self.line = oldToken.line
            self.charPositionInLine = oldToken.charPositionInLine
            self.channel = oldToken.channel
            
        self.text = text
        self.type = type
        self.line = None
        self.charPositionInLine = None
        self.channel = channel
        self.index = None


    def getText(self):
        return self.text

    def setText(self, text):
        self.text = text


    def getType(self):
        return self.type 

    def setType(self, ttype):
        self.type = ttype

    
    def getLine(self):
        return self.line
    
    def setLine(self, line):
        self.line = line


    def getCharPositionInLine(self):
        return self.charPositionInLine
    
    def setCharPositionInLine(self, pos):
        self.charPositionInLine = pos


    def getChannel(self):
        return self.channel
    
    def setChannel(self, channel):
        self.channel = channel
    

    def getTokenIndex(self):
        return self.index
    
    def setTokenIndex(self, index):
        self.index = index


    def toString(self):
        channelStr = ""
        if self.channel > 0:
            channelStr = ",channel=" + str(self.channel)
            
        txt = self.text
        if txt is None:
            txt = "<no text>"

        return "[@%r,%r,<%r>%s,%r:%r]" % (self.index,
                                          txt,
                                          self.type,
                                          channelStr,
                                          self.line,
                                          self.charPositionInLine
                                          )
    

    __str__ = toString
    __repr__ = toString



EOF_TOKEN = CommonToken(type=EOF)
	
INVALID_TOKEN = CommonToken(type=INVALID_TOKEN_TYPE)

# In an action, a lexer rule can set token to this SKIP_TOKEN and ANTLR
# will avoid creating a token for this symbol and try to fetch another.
SKIP_TOKEN = CommonToken(type=INVALID_TOKEN_TYPE)


"""ANTLR3 runtime package"""


import codecs
from StringIO import StringIO

from antlr3.constants import DEFAULT_CHANNEL, EOF
from antlr3.tokens import Token, EOF_TOKEN


############################################################################
#
# basic interfaces
#   IntStream
#    +- CharStream
#    \- TokenStream7
#
# subclasses must implemented all methods
#
############################################################################

class IntStream(object):
    """
    @brief Base interface for streams of integer values.

    A simple stream of integers used when all I care about is the char
    or token type sequence (such as interpretation).
    """
    
    def consume(self):
        raise NotImplementedError
    

    def LA(self, i):
        """Get int at current input pointer + i ahead where i=1 is next int.

        Negative indexes are allowed.  LA(-1) is previous token (token
	just matched).  LA(-i) where i is before first token should
	yield -1, invalid char / EOF.
	"""
        
        raise NotImplementedError
        

    def mark(self):
        """
        Tell the stream to start buffering if it hasn't already.  Return
        current input position, index(), or some other marker so that
        when passed to rewind() you get back to the same spot.
        rewind(mark()) should not affect the input cursor.  The Lexer
        track line/col info as well as input index so its markers are
        not pure input indexes.  Same for tree node streams.
        """

        raise NotImplementedError


    def index(self):
        """
        Return the current input symbol index 0..n where n indicates the
        last symbol has been read.  The index is the symbol about to be
        read not the most recently read symbol.
        """

        raise NotImplementedError


    def rewind(self, marker=None):
        """
        Reset the stream so that next call to index would return marker.
        The marker will usually be index() but it doesn't have to be.  It's
        just a marker to indicate what state the stream was in.  This is
        essentially calling release() and seek().  If there are markers
        created after this marker argument, this routine must unroll them
        like a stack.  Assume the state the stream was in when this marker
        was created.

        If marker is None:
        Rewind to the input position of the last marker.
        Used currently only after a cyclic DFA and just
        before starting a sem/syn predicate to get the
        input position back to the start of the decision.
        Do not "pop" the marker off the state.  mark(i)
        and rewind(i) should balance still. It is
        like invoking rewind(last marker) but it should not "pop"
        the marker off.  It's like seek(last marker's input position).       
	"""

        raise NotImplementedError


    def release(self, marker=None):
        """
        You may want to commit to a backtrack but don't want to force the
        stream to keep bookkeeping objects around for a marker that is
        no longer necessary.  This will have the same behavior as
        rewind() except it releases resources without the backward seek.
        This must throw away resources for all markers back to the marker
        argument.  So if you're nested 5 levels of mark(), and then release(2)
        you have to release resources for depths 2..5.
	"""

        raise NotImplementedError


    def seek(self, index):
        """
        Set the input cursor to the position indicated by index.  This is
        normally used to seek ahead in the input stream.  No buffering is
        required to do this unless you know your stream will use seek to
        move backwards such as when backtracking.

        This is different from rewind in its multi-directional
        requirement and in that its argument is strictly an input cursor
        (index).

        For char streams, seeking forward must update the stream state such
        as line number.  For seeking backwards, you will be presumably
        backtracking using the mark/rewind mechanism that restores state and
        so this method does not need to update state when seeking backwards.

        Currently, this method is only used for efficient backtracking using
        memoization, but in the future it may be used for incremental parsing.

        The index is 0..n-1.  A seek to position i means that LA(1) will
        return the ith symbol.  So, seeking to 0 means LA(1) will return the
        first element in the stream. 
        """

        raise NotImplementedError


    def size(self):
        """
        Only makes sense for streams that buffer everything up probably, but
        might be useful to display the entire stream or for testing.  This
        value includes a single EOF.
	"""

        raise NotImplementedError



class CharStream(IntStream):
    """
    @brief A source of characters for an ANTLR lexer.

    This is an abstract class that must be implemented by a subclass.
    
    """

    # pylint does not realize that this is an interface, too
    #pylint: disable-msg=W0223
    
    EOF = -1


    def substring(self, start, stop):
        """
        For infinite streams, you don't need this; primarily I'm providing
        a useful interface for action code.  Just make sure actions don't
        use this on streams that don't support it.
        """

        raise NotImplementedError
        
    
    def LT(self, i):
        """
        Get the ith character of lookahead.  This is the same usually as
        LA(i).  This will be used for labels in the generated
        lexer code.  I'd prefer to return a char here type-wise, but it's
        probably better to be 32-bit clean and be consistent with LA.
        """

        raise NotImplementedError


    def getLine(self):
        """ANTLR tracks the line information automatically"""

        raise NotImplementedError


    def setLine(self, line):
        """
        Because this stream can rewind, we need to be able to reset the line
        """

        raise NotImplementedError


    def getCharPositionInLine(self):
        """
        The index of the character relative to the beginning of the line 0..n-1
        """

        raise NotImplementedError


    def setCharPositionInLine(self, pos):
        raise NotImplementedError


class TokenStream(IntStream):
    """

    @brief A stream of tokens accessing tokens from a TokenSource

    This is an abstract class that must be implemented by a subclass.
    
    """
    
    # pylint does not realize that this is an interface, too
    #pylint: disable-msg=W0223
    
    def LT(self, k):
        """
        Get Token at current input pointer + i ahead where i=1 is next Token.
        i<0 indicates tokens in the past.  So -1 is previous token and -2 is
        two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
        Return null for LT(0) and any index that results in an absolute address
        that is negative.
	"""

        raise NotImplementedError


    def get(self, i):
        """
        Get a token at an absolute index i; 0..n-1.  This is really only
        needed for profiling and debugging and token stream rewriting.
        If you don't want to buffer up tokens, then this method makes no
        sense for you.  Naturally you can't use the rewrite stream feature.
        I believe DebugTokenStream can easily be altered to not use
        this method, removing the dependency.
        """

        raise NotImplementedError


    def getTokenSource(self):
        """
        Where is this stream pulling tokens from?  This is not the name, but
        the object that provides Token objects.
	"""

        raise NotImplementedError


    def toString(self, start=None, stop=None):
        """
        Return the text of all tokens from start to stop, inclusive.
        If the stream does not buffer all the tokens then it can just
        return "" or null;  Users should not access $ruleLabel.text in
        an action of course in that case.

        Because the user is not required to use a token with an index stored
        in it, we must provide a means for two token objects themselves to
        indicate the start/end location.  Most often this will just delegate
        to the other toString(int,int).  This is also parallel with
        the TreeNodeStream.toString(Object,Object).
	"""

        raise NotImplementedError

        
############################################################################
#
# character streams for use in lexers
#   CharStream
#   \- ANTLRStringStream
#
############################################################################


class ANTLRStringStream(CharStream):
    """
    @brief CharStream that pull data from a unicode string.
    
    A pretty quick CharStream that pulls all data from an array
    directly.  Every method call counts in the lexer.

    """

    
    def __init__(self, data):
        """
        @param data This should be a unicode string holding the data you want
           to parse. If you pass in a byte string, the Lexer will choke on
           non-ascii data.
           
        """
        
        CharStream.__init__(self)
        
  	# The data being scanned
        self.data = data

	# How many characters are actually in the buffer
        self.n = len(data)

 	# 0..n-1 index into string of next char
        self.p = 0

	# line number 1..n within the input
        self.line = 1

 	# The index of the character relative to the beginning of the
        # line 0..n-1
        self.charPositionInLine = 0

	# A list of CharStreamState objects that tracks the stream state
        # values line, charPositionInLine, and p that can change as you
        # move through the input stream.  Indexed from 0..markDepth-1.
        self._markers = [ ]
        self.lastMarker = None
        self.markDepth = 0
        

    def reset(self):
        """
        Reset the stream so that it's in the same state it was
        when the object was created *except* the data array is not
        touched.
        """
        
        self.p = 0
        self.line = 1
        self.charPositionInLine = 0
        self._markers = [ ]


    def consume(self):
        if self.p < self.n:
            self.charPositionInLine += 1
            if self.data[self.p] == '\n':
                self.line += 1
                self.charPositionInLine = 0

            self.p += 1


    def LA(self, i):
        if i == 0:
            return 0 # undefined

        if i < 0:
            i += 1 # e.g., translate LA(-1) to use offset i=0; then data[p+0-1]
            if self.p+i-1 < 0:
                return EOF # invalid; no char before first char

        if self.p+i-1 >= self.n:
            return EOF

        return self.data[self.p+i-1]

    LT = LA

    def index(self):
        """
        Return the current input symbol index 0..n where n indicates the
        last symbol has been read.  The index is the index of char to
        be returned from LA(1).
        """
        
        return self.p


    def size(self):
        return self.n


    def mark(self):
        state = (self.p, self.line, self.charPositionInLine)
        try:
            self._markers[self.markDepth] = state
        except IndexError:
            self._markers.append(state)
        self.markDepth += 1
        
        self.lastMarker = self.markDepth
        
        return self.lastMarker


    def rewind(self, marker=None):
        if marker is None:
            marker = self.lastMarker

        p, line, charPositionInLine = self._markers[marker-1]

        self.seek(p)
        self.line = line
        self.charPositionInLine = charPositionInLine
        self.release(marker)


    def release(self, marker=None):
        if marker is None:
            marker = self.lastMarker

        self.markDepth = marker-1


    def seek(self, index):
        """
        consume() ahead until p==index; can't just set p=index as we must
        update line and charPositionInLine.
        """
        
        if index <= self.p:
            self.p = index # just jump; don't update stream state (line, ...)
            return

        # seek forward, consume until p hits index
        while self.p < index:
            self.consume()


    def substring(self, start, stop):
        return self.data[start:stop+1]


    def getLine(self):
        """Using setter/getter methods is deprecated. Use o.line instead."""
        return self.line


    def getCharPositionInLine(self):
        """Using setter/getter methods is deprecated. Use o.charPositionInLine instead."""
        return self.charPositionInLine


    def setLine(self, line):
        """Using setter/getter methods is deprecated. Use o.line instead."""
        self.line = line


    def setCharPositionInLine(self, pos):
        """Using setter/getter methods is deprecated. Use o.charPositionInLine instead."""
        self.charPositionInLine = pos


class ANTLRFileStream(ANTLRStringStream):
    """
    @brief CharStream that opens a file to read the data.
    
    This is a char buffer stream that is loaded from a file
    all at once when you construct the object.
    """

    def __init__(self, fileName, encoding=None):
        """
        @param fileName The path to the file to be opened. The file will be
           opened with mode 'rb'.

        @param encoding If you set the optional encoding argument, then the
           data will be decoded on the fly.
           
        """
        
        self.fileName = fileName

        fp = codecs.open(fileName, 'rb', encoding)
        try:
            data = fp.read()
        finally:
            fp.close()
            
        ANTLRStringStream.__init__(self, data)


    def getSourceName(self):
        """Deprecated, access o.fileName directly."""
        
        return self.fileName


class ANTLRInputStream(ANTLRStringStream):
    """
    @brief CharStream that reads data from a file-like object.

    This is a char buffer stream that is loaded from a file like object
    all at once when you construct the object.
    
    All input is consumed from the file, but it is not closed.
    """

    def __init__(self, file, encoding=None):
        """
        @param file A file-like object holding your input. Only the read()
           method must be implemented.

        @param encoding If you set the optional encoding argument, then the
           data will be decoded on the fly.
           
        """
        
        if encoding is not None:
            # wrap input in a decoding reader
            reader = codecs.lookup(encoding)[2]
            file = reader(file)

        data = file.read()
            
        ANTLRStringStream.__init__(self, data)


# I guess the ANTLR prefix exists only to avoid a name clash with some Java
# mumbojumbo. A plain "StringStream" looks better to me, which should be
# the preferred name in Python.
StringStream = ANTLRStringStream
FileStream = ANTLRFileStream
InputStream = ANTLRInputStream


############################################################################
#
# Token streams
#   TokenStream
#   +- CommonTokenStream
#   \- TokenRewriteStream
#
############################################################################


class CommonTokenStream(TokenStream):
    """
    @brief The most common stream of tokens
    
    The most common stream of tokens is one where every token is buffered up
    and tokens are prefiltered for a certain channel (the parser will only
    see these tokens and cannot change the filter channel number during the
    parse).
    """

    def __init__(self, tokenSource=None, channel=DEFAULT_CHANNEL):
        """
        @param tokenSource A TokenSource instance (usually a Lexer) to pull
            the tokens from.

        @param channel Skip tokens on any channel but this one; this is how we
            skip whitespace...
            
        """
        
        TokenStream.__init__(self)
        
        self.tokenSource = tokenSource

	# Record every single token pulled from the source so we can reproduce
        # chunks of it later.
        self.tokens = []

	# Map<tokentype, channel> to override some Tokens' channel numbers
        self.channelOverrideMap = {}

	# Set<tokentype>; discard any tokens with this type
        self.discardSet = set()

	# Skip tokens on any channel but this one; this is how we skip whitespace...
        self.channel = channel

	# By default, track all incoming tokens
        self.discardOffChannelTokens = False

	# The index into the tokens list of the current token (next token
        # to consume).  p==-1 indicates that the tokens list is empty
        self.p = -1

        # Remember last marked position
        self.lastMarker = None
        

    def setTokenSource(self, tokenSource):
        """Reset this token stream by setting its token source."""
        
        self.tokenSource = tokenSource
        self.tokens = []
        self.p = -1
        self.channel = DEFAULT_CHANNEL


    def fillBuffer(self):
        """
        Load all tokens from the token source and put in tokens.
	This is done upon first LT request because you might want to
        set some token type / channel overrides before filling buffer.
        """
        

        index = 0
        t = self.tokenSource.nextToken()
        while t is not None and t.type != EOF:
            discard = False
            
            if self.discardSet is not None and t.type in self.discardSet:
                discard = True

            elif self.discardOffChannelTokens and t.channel != self.channel:
                discard = True

            # is there a channel override for token type?
            try:
                overrideChannel = self.channelOverrideMap[t.type]
                
            except KeyError:
                # no override for this type
                pass
            
            else:
                if overrideChannel == self.channel:
                    t.channel = overrideChannel
                else:
                    discard = True
            
            if not discard:
                t.index = index
                self.tokens.append(t)
                index += 1

            t = self.tokenSource.nextToken()
       
        # leave p pointing at first token on channel
        self.p = 0
        self.p = self.skipOffTokenChannels(self.p)


    def consume(self):
        """
        Move the input pointer to the next incoming token.  The stream
        must become active with LT(1) available.  consume() simply
        moves the input pointer so that LT(1) points at the next
        input symbol. Consume at least one token.

        Walk past any token not on the channel the parser is listening to.
        """
        
        if self.p < len(self.tokens):
            self.p += 1

            self.p = self.skipOffTokenChannels(self.p) # leave p on valid token


    def skipOffTokenChannels(self, i):
        """
        Given a starting index, return the index of the first on-channel
        token.
        """

        n = len(self.tokens)
        while i < n and self.tokens[i].channel != self.channel:
            i += 1

        return i


    def skipOffTokenChannelsReverse(self, i):
        while i >= 0 and self.tokens[i].channel != self.channel:
            i -= 1

        return i


    def setTokenTypeChannel(self, ttype, channel):
        """
        A simple filter mechanism whereby you can tell this token stream
        to force all tokens of type ttype to be on channel.  For example,
        when interpreting, we cannot exec actions so we need to tell
        the stream to force all WS and NEWLINE to be a different, ignored
        channel.
	"""
        
        self.channelOverrideMap[ttype] = channel


    def discardTokenType(self, ttype):
        self.discardSet.add(ttype)


    def getTokens(self, start=None, stop=None, types=None):
        """
        Given a start and stop index, return a list of all tokens in
        the token type set.  Return None if no tokens were found.  This
        method looks at both on and off channel tokens.
        """

        if self.p == -1:
            self.fillBuffer()

        if stop is None or stop >= len(self.tokens):
            stop = len(self.tokens) - 1
            
        if start is None or stop < 0:
            start = 0

        if start > stop:
            return None

        if isinstance(types, (int, long)):
            # called with a single type, wrap into set
            types = set([types])
            
        filteredTokens = [
            token for token in self.tokens[start:stop]
            if types is None or token.type in types
            ]

        if len(filteredTokens) == 0:
            return None

        return filteredTokens


    def LT(self, k):
        """
        Get the ith token from the current position 1..n where k=1 is the
        first symbol of lookahead.
        """

        if self.p == -1:
            self.fillBuffer()

        if k == 0:
            return None

        if k < 0:
            return self.LB(-k)
                
        if self.p + k - 1 >= len(self.tokens):
            return EOF_TOKEN

        i = self.p
        n = 1
        # find k good tokens
        while n < k:
            # skip off-channel tokens
            i = self.skipOffTokenChannels(i+1) # leave p on valid token
            n += 1
        
        if i >= len(self.tokens):
            return EOF_TOKEN

        return self.tokens[i]


    def LB(self, k):
        """Look backwards k tokens on-channel tokens"""

        if self.p == -1:
            self.fillBuffer()

        if k == 0:
            return None

        if self.p - k < 0:
            return None

        i = self.p
        n = 1
        # find k good tokens looking backwards
        while n <= k:
            # skip off-channel tokens
            i = self.skipOffTokenChannelsReverse(i-1) # leave p on valid token
            n += 1

        if i < 0:
            return None
            
        return self.tokens[i]


    def get(self, i):
        """
        Return absolute token i; ignore which channel the tokens are on;
        that is, count all tokens not just on-channel tokens.
        """

        return self.tokens[i]


    def LA(self, i):
        return self.LT(i).type


    def mark(self):
        self.lastMarker = self.index()
        return self.lastMarker
    

    def release(self, marker=None):
        # no resources to release
        pass
    

    def size(self):
        return len(self.tokens)


    def index(self):
        return self.p


    def rewind(self, marker=None):
        if marker is None:
            marker = self.lastMarker
            
        self.seek(marker)


    def seek(self, index):
        self.p = index


    def getTokenSource(self):
        return self.tokenSource


    def toString(self, start=None, stop=None):
        if self.p == -1:
            self.fillBuffer()

        if start is None:
            start = 0
        elif not isinstance(start, int):
            start = start.index

        if stop is None:
            stop = len(self.tokens) - 1
        elif not isinstance(stop, int):
            stop = stop.index
        
        if stop >= len(self.tokens):
            stop = len(self.tokens) - 1

        return ''.join([t.text for t in self.tokens[start:stop+1]])


class RewriteOperation(object):
    """@brief Internal helper class."""
    
    def __init__(self, index, text):
        self.index = index
        self.text = text

    def execute(self, buf):
        """Execute the rewrite operation by possibly adding to the buffer.
        Return the index of the next token to operate on.
        """

        return self.index

    def toString(self):
        opName = self.__class__.__name__
        return opName+"@"+self.index+'"'+self.text+'"'

    __str__ = toString


class InsertBeforeOp(RewriteOperation):
    """@brief Internal helper class."""

    def execute(self, buf):
        buf.write(self.text)
        return self.index


class ReplaceOp(RewriteOperation):
    """
    @brief Internal helper class.
    
    I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
    instructions.
    """

    def __init__(self, first, last, text):
        RewriteOperation.__init__(self, first, text)
        self.lastIndex = last


    def execute(self, buf):
        if self.text is not None:
            buf.write(self.text)

        return self.lastIndex + 1


class TokenRewriteStream(CommonTokenStream):
    """@brief CommonTokenStream that can be modified.

    Useful for dumping out the input stream after doing some
    augmentation or other manipulations.

    You can insert stuff, replace, and delete chunks.  Note that the
    operations are done lazily--only if you convert the buffer to a
    String.  This is very efficient because you are not moving data around
    all the time.  As the buffer of tokens is converted to strings, the
    toString() method(s) check to see if there is an operation at the
    current index.  If so, the operation is done and then normal String
    rendering continues on the buffer.  This is like having multiple Turing
    machine instruction streams (programs) operating on a single input tape. :)

    Since the operations are done lazily at toString-time, operations do not
    screw up the token index values.  That is, an insert operation at token
    index i does not change the index values for tokens i+1..n-1.

    Because operations never actually alter the buffer, you may always get
    the original token stream back without undoing anything.  Since
    the instructions are queued up, you can easily simulate transactions and
    roll back any changes if there is an error just by removing instructions.
    For example,

     CharStream input = new ANTLRFileStream("input");
     TLexer lex = new TLexer(input);
     TokenRewriteStream tokens = new TokenRewriteStream(lex);
     T parser = new T(tokens);
     parser.startRule();

     Then in the rules, you can execute
        Token t,u;
        ...
        input.insertAfter(t, "text to put after t");}
        input.insertAfter(u, "text after u");}
        System.out.println(tokens.toString());

    Actually, you have to cast the 'input' to a TokenRewriteStream. :(

    You can also have multiple "instruction streams" and get multiple
    rewrites from a single pass over the input.  Just name the instruction
    streams and use that name again when printing the buffer.  This could be
    useful for generating a C file and also its header file--all from the
    same buffer:

        tokens.insertAfter("pass1", t, "text to put after t");}
        tokens.insertAfter("pass2", u, "text after u");}
        System.out.println(tokens.toString("pass1"));
        System.out.println(tokens.toString("pass2"));

    If you don't use named rewrite streams, a "default" stream is used as
    the first example shows.
    """
    
    DEFAULT_PROGRAM_NAME = "default"
    MIN_TOKEN_INDEX = 0

    def __init__(self, tokenSource=None, channel=DEFAULT_CHANNEL):
        CommonTokenStream.__init__(self, tokenSource, channel)

        # You may have multiple, named streams of rewrite operations.
        # I'm calling these things "programs."
        #  Maps String (name) -> rewrite (List)
        self.programs = {}
        self.programs[self.DEFAULT_PROGRAM_NAME] = []
        
 	# Map String (program name) -> Integer index
        self.lastRewriteTokenIndexes = {}
        

    def rollback(self, *args):
        """
        Rollback the instruction stream for a program so that
        the indicated instruction (via instructionIndex) is no
        longer in the stream.  UNTESTED!
        """

        if len(args) == 2:
            programName = args[0]
            instructionIndex = args[1]
        elif len(args) == 1:
            programName = self.DEFAULT_PROGRAM_NAME
            instructionIndex = args[0]
        else:
            raise TypeError("Invalid arguments")
        
        p = self.programs.get(programName, None)
        if p is not None:
            self.programs[programName] = p[self.MIN_TOKEN_INDEX:instructionIndex]


    def deleteProgram(self, programName=DEFAULT_PROGRAM_NAME):
        """Reset the program so that no instructions exist"""
            
        self.rollback(programName, self.MIN_TOKEN_INDEX)


    def addToSortedRewriteList(self, *args):
        """
        Add an instruction to the rewrite instruction list ordered by
        the instruction number (do not use a binary search for bad efficiency).
        The list is ordered so that toString() can be done efficiently.

        When there are multiple instructions at the same index, the instructions
        must be ordered to ensure proper behavior.  For example, a delete at
        index i must kill any replace operation at i.  Insert-before operations
        must come before any replace / delete instructions.  If there are
        multiple insert instructions for a single index, they are done in
        reverse insertion order so that "insert foo" then "insert bar" yields
        "foobar" in front rather than "barfoo".  This is convenient because
        I can insert new InsertOp instructions at the index returned by
        the binary search.  A ReplaceOp kills any previous replace op.  Since
        delete is the same as replace with null text, i can check for
        ReplaceOp and cover DeleteOp at same time. :)
        """

        if len(args) == 2:
            programName = args[0]
            op = args[1]
        elif len(args) == 1:
            programName = self.DEFAULT_PROGRAM_NAME
            op = args[0]
        else:
            raise TypeError("Invalid arguments")
        
        rewrites = self.getProgram(programName)
        #System.out.println("### add "+op+"; rewrites="+rewrites)

        # first insert position for operation
        for pos, searchOp in enumerate(rewrites):
            if searchOp.index == op.index:
                # now pos is the index in rewrites of first op with op.index
                #System.out.println("first op with op.index: pos="+pos)

                # an instruction operating already on that index was found;
                # make this one happen after all the others
                #System.out.println("found instr for index="+op.index)
                if isinstance(op, ReplaceOp):
                    replaced = False
                    i = pos
                    # look for an existing replace
                    while i < len(rewrites):
                        prevOp = rewrites[pos]
                        if prevOp.index != op.index:
                            break

                        if isinstance(prevOp, ReplaceOp):
                            rewrites[pos] = op # replace old with new
                            replaced = True
                            break

                        # keep going; must be an insert
                        i += 1
                        
                    if not replaced:
                        # add replace op to the end of all the inserts
                        rewrites.insert(i, op)

                else:
                    # inserts are added in front of existing inserts
                    rewrites.insert(pos, op)

                break

            elif searchOp.index > op.index:
                #System.out.println("no instruction at pos=="+pos)
                rewrites.insert(pos, op)
                break
            
        else:
            # new op is past any existing op, append to end
            rewrites.append(op)
            
        #System.out.println("after, rewrites="+rewrites)


    def insertAfter(self, *args):
        if len(args) == 2:
            programName = self.DEFAULT_PROGRAM_NAME
            index = args[0]
            text = args[1]
            
        elif len(args) == 3:
            programName = args[0]
            index = args[1]
            text = args[2]

        else:
            raise TypeError("Invalid arguments")

        if isinstance(index, Token):
            # index is a Token, grap the stream index from it
            index = index.index

        # to insert after, just insert before next index (even if past end)
        self.insertBefore(programName, index+1, text)


    def insertBefore(self, *args):
        if len(args) == 2:
            programName = self.DEFAULT_PROGRAM_NAME
            index = args[0]
            text = args[1]
            
        elif len(args) == 3:
            programName = args[0]
            index = args[1]
            text = args[2]

        else:
            raise TypeError("Invalid arguments")

        if isinstance(index, Token):
            # index is a Token, grap the stream index from it
            index = index.index

        self.addToSortedRewriteList(
            programName,
            InsertBeforeOp(index, text)
            )


    def replace(self, *args):
        if len(args) == 2:
            programName = self.DEFAULT_PROGRAM_NAME
            first = args[0]
            last = args[0]
            text = args[1]
            
        elif len(args) == 3:
            programName = self.DEFAULT_PROGRAM_NAME
            first = args[0]
            last = args[1]
            text = args[2]
            
        elif len(args) == 4:
            programName = args[0]
            first = args[1]
            last = args[2]
            text = args[3]

        else:
            raise TypeError("Invalid arguments")

        if isinstance(first, Token):
            # first is a Token, grap the stream index from it
            first = first.index

        if isinstance(last, Token):
            # last is a Token, grap the stream index from it
            last = last.index

        if first > last or first < 0 or last < 0:
            return
        
        self.addToSortedRewriteList(
            programName,
            ReplaceOp(first, last, text)
            )
        

    def delete(self, *args):
        self.replace(*(list(args) + [None]))


    def getLastRewriteTokenIndex(self, programName=DEFAULT_PROGRAM_NAME):
        return self.lastRewriteTokenIndexes.get(programName, -1)


    def setLastRewriteTokenIndex(self, programName, i):
        self.lastRewriteTokenIndexes[programName] = i


    def getProgram(self, name):
        p = self.programs.get(name, None)
        if p is  None:
            p = self.initializeProgram(name)

        return p


    def initializeProgram(self, name):
        p = []
        self.programs[name] = p
        return p


    def toOriginalString(self, start=None, end=None):
        if start is None:
            start = self.MIN_TOKEN_INDEX
        if end is None:
            end = self.size() - 1
        
        buf = StringIO()
        i = start
        while i >= self.MIN_TOKEN_INDEX and i <= end and i < len(self.tokens):
            buf.write(self.get(i).text)
            i += 1

        return buf.getvalue()


    def toString(self, *args):
        if len(args) == 0:
            programName = self.DEFAULT_PROGRAM_NAME
            start = self.MIN_TOKEN_INDEX
            end = self.size() - 1
            
        elif len(args) == 1:
            programName = args[0]
            start = self.MIN_TOKEN_INDEX
            end = self.size() - 1

        elif len(args) == 2:
            programName = self.DEFAULT_PROGRAM_NAME
            start = args[0]
            end = args[1]
            
        rewrites = self.programs.get(programName)
        if rewrites is None or len(rewrites) == 0:
            # no instructions to execute
            return self.toOriginalString(start, end)
        
        buf = StringIO()

        # Index of first rewrite we have not done
        rewriteOpIndex = 0

        tokenCursor = start
        while ( tokenCursor >= self.MIN_TOKEN_INDEX
                and tokenCursor <= end
                and tokenCursor < len(self.tokens)
                ):
            #System.out.println("tokenCursor="+tokenCursor);
            # execute instructions associated with this token index
            if rewriteOpIndex < len(rewrites):
                op = rewrites[rewriteOpIndex]

                # skip all ops at lower index
                while ( op.index < tokenCursor
                        and rewriteOpIndex < len(rewrites)
                        ):
                    rewriteOpIndex += 1
                    if rewriteOpIndex < len(rewrites):
                        op = rewrites[rewriteOpIndex]

                # while we have ops for this token index, exec them
                while ( tokenCursor == op.index
                        and rewriteOpIndex < len(rewrites)
                        ):
                    #System.out.println("execute "+op+" at instruction "+rewriteOpIndex);
                    tokenCursor = op.execute(buf)
                    #System.out.println("after execute tokenCursor = "+tokenCursor);
                    rewriteOpIndex += 1
                    if rewriteOpIndex < len(rewrites):
                        op = rewrites[rewriteOpIndex]

            # dump the token at this index
            if tokenCursor <= end:
                buf.write(self.get(tokenCursor).text)
                tokenCursor += 1
        
        # now see if there are operations (append) beyond last token index
        for opi in range(rewriteOpIndex, len(rewrites)):
            op = rewrites[opi]
            
            if op.index >= self.size():
                op.execute(buf) # must be insertions if after last token

            #System.out.println("execute "+op+" at "+opi);
            #op.execute(buf); # must be insertions if after last token


        return buf.getvalue()

    __str__ = toString
    

    def toDebugString(self, start=None, end=None):
        if start is None:
            start = self.MIN_TOKEN_INDEX
        if end is None:
            end = self.size() - 1
        
        buf = StringIO()
        i = start
        while i >= self.MIN_TOKEN_INDEX and i <= end and i < len(self.tokens):
            buf.write(self.get(i))
            i += 1

        return buf.getvalue()
"""ANTLR3 runtime package"""


import sys
import inspect

from antlr3.constants import DEFAULT_CHANNEL, HIDDEN_CHANNEL, EOF, \
     EOR_TOKEN_TYPE, INVALID_TOKEN_TYPE
from antlr3.exceptions import RecognitionException, MismatchedTokenException, \
     MismatchedRangeException, MismatchedTreeNodeException, \
     NoViableAltException, EarlyExitException, MismatchedSetException, \
     MismatchedNotSetException, FailedPredicateException
from antlr3.tokens import CommonToken, EOF_TOKEN, SKIP_TOKEN
from antlr3.compat import set, frozenset, reversed


class BaseRecognizer(object):
    """
    @brief Common recognizer functionality.
    
    A generic recognizer that can handle recognizers generated from
    lexer, parser, and tree grammars.  This is all the parsing
    support code essentially; most of it is error recovery stuff and
    backtracking.
    """

    MEMO_RULE_FAILED = -2
    MEMO_RULE_UNKNOWN = -1

    # copies from Token object for convenience in actions
    DEFAULT_TOKEN_CHANNEL = DEFAULT_CHANNEL

    # for convenience in actions
    HIDDEN = HIDDEN_CHANNEL

    # overridden by generated subclasses
    tokenNames = None
    
    def __init__(self):
        # Input stream of the recognizer. Must be initialized by a subclass.
        self.input = None
        
        # Track the set of token types that can follow any rule invocation.
        # Stack grows upwards.  When it hits the max, it grows 2x in size
        # and keeps going.
        self.following = []

        # This is true when we see an error and before having successfully
        # matched a token.  Prevents generation of more than one error message
        # per error.
        self.errorRecovery = False

        # The index into the input stream where the last error occurred.
        # This is used to prevent infinite loops where an error is found
        # but no token is consumed during recovery...another error is found,
        # ad naseum.  This is a failsafe mechanism to guarantee that at least
        # one token/tree node is consumed for two errors.
        self.lastErrorIndex = -1

        # In lieu of a return value, this indicates that a rule or token
        # has failed to match.  Reset to false upon valid token match.
        self.failed = False

        # If 0, no backtracking is going on.  Safe to exec actions etc...
        # If >0 then it's the level of backtracking.
        self.backtracking = 0

        # An array[size num rules] of Map<Integer,Integer> that tracks
        # the stop token index for each rule.  ruleMemo[ruleIndex] is
        # the memoization table for ruleIndex.  For key ruleStartIndex, you
        # get back the stop token for associated rule or MEMO_RULE_FAILED.
        #
        #  This is only used if rule memoization is on (which it is by default).
        self.ruleMemo = None


    # this one only exists to shut up pylint :(
    def setInput(self, input):
        self.input = input

        
    def reset(self):
        """
        reset the parser's state; subclasses must rewinds the input stream
        """
        
        # wack everything related to error recovery
        self.errorRecovery = False
        self.lastErrorIndex = -1
        self.failed = False
        # wack everything related to backtracking and memoization
        self.backtracking = 0
        if self.ruleMemo is not None:
            self.ruleMemo = {}


    def match(self, input, ttype, follow):
        """
        Match current input symbol against ttype.  Upon error, do one token
        insertion or deletion if possible.  You can override to not recover
	here and bail out of the current production to the normal error
	exception catch (at the end of the method) by just throwing
	MismatchedTokenException upon input.LA(1)!=ttype.
        """
        
        if self.input.LA(1) == ttype:
            self.input.consume()
            self.errorRecovery = False
            self.failed = False
            return

        if self.backtracking > 0:
            self.failed = True
            return

        self.mismatch(input, ttype, follow)
        return


    def matchAny(self, input):
        self.errorRecovery = False
        self.failed = False
        self.input.consume()


    def mismatch(self, input, ttype, follow):
        """
        factor out what to do upon token mismatch so tree parsers can behave
        differently.  Override this method in your parser to do things
	like bailing out after the first error; just throw the mte object
	instead of calling the recovery method.
        """
        
        mte = MismatchedTokenException(ttype, input)
        self.recoverFromMismatchedToken(input, mte, ttype, follow)


    def reportError(self, e):
        """Report a recognition problem.
            
        This method sets errorRecovery to indicate the parser is recovering
        not parsing.  Once in recovery mode, no errors are generated.
        To get out of recovery mode, the parser must successfully match
        a token (after a resync).  So it will go:

        -# error occurs
        -# enter recovery mode, report error
        -# consume until token found in resynch set
        -# try to resume parsing
        -# next match() will reset errorRecovery mode
        .
        
        """
        
        # if we've already reported an error and have not matched a token
        # yet successfully, don't report any errors.
        if self.errorRecovery:
            return

        self.errorRecovery = True

        self.displayRecognitionError(self.tokenNames, e)


    def displayRecognitionError(self, tokenNames, e):
        hdr = self.getErrorHeader(e)
        msg = self.getErrorMessage(e, tokenNames)
        self.emitErrorMessage(hdr+" "+msg)


    def getErrorMessage(self, e, tokenNames):
        """
        What error message should be generated for the various
        exception types?
        
        Not very object-oriented code, but I like having all error message
        generation within one method rather than spread among all of the
	exception classes. This also makes it much easier for the exception
	handling because the exception classes do not have to have pointers back
	to this object to access utility routines and so on. Also, changing
	the message for an exception type would be difficult because you
	would have to subclassing exception, but then somehow get ANTLR
	to make those kinds of exception objects instead of the default.
	This looks weird, but trust me--it makes the most sense in terms
	of flexibility.

        For grammar debugging, you will want to override this to add
	more information such as the stack frame with
	getRuleInvocationStack(e, this.getClass().getName()) and,
	for no viable alts, the decision description and state etc...

        Override this to change the message generated for one or more
	exception types.
        """

        msg = None
        if isinstance(e, MismatchedTokenException):
            tokenName = "<unknown>"
            if e.expecting == EOF:
                tokenName = "EOF"
            else:
                tokenName = self.tokenNames[e.expecting]

            msg = "mismatched input " \
                  + self.getTokenErrorDisplay(e.token) \
                  + " expecting " \
                  + tokenName

        elif isinstance(e, MismatchedTreeNodeException):
            tokenName = "<unknown>"
            if e.expecting == EOF:
                tokenName = "EOF"
            else:
                tokenName = self.tokenNames[e.expecting]

            msg = "mismatched tree node: " \
                  + e.node \
                  + " expecting " \
                  + tokenName

        elif isinstance(e, NoViableAltException):
            msg = "no viable alternative at input " \
                  + self.getTokenErrorDisplay(e.token)

        elif isinstance(e, EarlyExitException):
            msg = "required (...)+ loop did not match anything at input " \
                  + self.getTokenErrorDisplay(e.token)

        elif isinstance(e, MismatchedSetException):
            msg = "mismatched input " \
                  + self.getTokenErrorDisplay(e.token) \
                  + " expecting set " \
                  + repr(e.expecting)

        elif isinstance(e, MismatchedNotSetException):
            msg = "mismatched input " \
                  + self.getTokenErrorDisplay(e.token) \
                  + " expecting set " \
                  + repr(e.expecting)

        elif isinstance(e, FailedPredicateException):
            msg = "rule " \
                  + e.ruleName \
                  + " failed predicate: {" \
                  + e.predicateText \
                  + "}?"

        
        return msg
    

    def getErrorHeader(self, e):
        """
        What is the error header, normally line/character position information?
        """
        
        return "line %d:%d" % (e.line, e.charPositionInLine)


    def getTokenErrorDisplay(self, t):
        """
        How should a token be displayed in an error message? The default
        is to display just the text, but during development you might
        want to have a lot of information spit out.  Override in that case
        to use t.toString() (which, for CommonToken, dumps everything about
        the token). This is better than forcing you to override a method in
        your token objects because you don't have to go modify your lexer
        so that it creates a new Java type.
        """
        
        s = t.text
        if s is None:
            if t.type == EOF:
                s = "<EOF>"
            else:
                s = "<"+t.type+">"

        return repr(s)
    

    def emitErrorMessage(self, msg):
        """Override this method to change where error messages go"""
        sys.stderr.write(msg + '\n')


    def recover(self, input, re):
        """
        Recover from an error found on the input stream.  Mostly this is
        NoViableAlt exceptions, but could be a mismatched token that
        the match() routine could not recover from.
        """
        
        # PROBLEM? what if input stream is not the same as last time
        # perhaps make lastErrorIndex a member of input
        if self.lastErrorIndex == input.index():
            # uh oh, another error at same token index; must be a case
            # where LT(1) is in the recovery token set so nothing is
            # consumed; consume a single token so at least to prevent
            # an infinite loop; this is a failsafe.
            input.consume()

        self.lastErrorIndex = input.index()
        followSet = self.computeErrorRecoverySet()
        
        self.beginResync()
        self.consumeUntil(input, followSet)
        self.endResync()


    def beginResync(self):
        """
        A hook to listen in on the token consumption during error recovery.
        The DebugParser subclasses this to fire events to the listenter.
        """

        pass


    def endResync(self):
        """
        A hook to listen in on the token consumption during error recovery.
        The DebugParser subclasses this to fire events to the listenter.
        """

        pass


    def computeErrorRecoverySet(self):
        """
        Compute the error recovery set for the current rule.  During
        rule invocation, the parser pushes the set of tokens that can
        follow that rule reference on the stack; this amounts to
        computing FIRST of what follows the rule reference in the
        enclosing rule. This local follow set only includes tokens
        from within the rule; i.e., the FIRST computation done by
        ANTLR stops at the end of a rule.

        EXAMPLE

        When you find a "no viable alt exception", the input is not
        consistent with any of the alternatives for rule r.  The best
        thing to do is to consume tokens until you see something that
        can legally follow a call to r *or* any rule that called r.
        You don't want the exact set of viable next tokens because the
        input might just be missing a token--you might consume the
        rest of the input looking for one of the missing tokens.

        Consider grammar:

        a : '[' b ']'
          | '(' b ')'
          ;
        b : c '^' INT ;
        c : ID
          | INT
          ;

        At each rule invocation, the set of tokens that could follow
        that rule is pushed on a stack.  Here are the various "local"
        follow sets:

        FOLLOW(b1_in_a) = FIRST(']') = ']'
        FOLLOW(b2_in_a) = FIRST(')') = ')'
        FOLLOW(c_in_b) = FIRST('^') = '^'

        Upon erroneous input "[]", the call chain is

        a -> b -> c

        and, hence, the follow context stack is:

        depth  local follow set     after call to rule
          0         \<EOF>                    a (from main())
          1          ']'                     b
          3          '^'                     c

        Notice that ')' is not included, because b would have to have
        been called from a different context in rule a for ')' to be
        included.

        For error recovery, we cannot consider FOLLOW(c)
        (context-sensitive or otherwise).  We need the combined set of
        all context-sensitive FOLLOW sets--the set of all tokens that
        could follow any reference in the call chain.  We need to
        resync to one of those tokens.  Note that FOLLOW(c)='^' and if
        we resync'd to that token, we'd consume until EOF.  We need to
        sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
        In this case, for input "[]", LA(1) is in this set so we would
        not consume anything and after printing an error rule c would
        return normally.  It would not find the required '^' though.
        At this point, it gets a mismatched token error and throws an
        exception (since LA(1) is not in the viable following token
        set).  The rule exception handler tries to recover, but finds
        the same recovery set and doesn't consume anything.  Rule b
        exits normally returning to rule a.  Now it finds the ']' (and
        with the successful match exits errorRecovery mode).

        So, you cna see that the parser walks up call chain looking
        for the token that was a member of the recovery set.

        Errors are not generated in errorRecovery mode.

        ANTLR's error recovery mechanism is based upon original ideas:

        "Algorithms + Data Structures = Programs" by Niklaus Wirth

        and

        "A note on error recovery in recursive descent parsers":
        http://portal.acm.org/citation.cfm?id=947902.947905

        Later, Josef Grosch had some good ideas:

        "Efficient and Comfortable Error Recovery in Recursive Descent
        Parsers":
        ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip

        Like Grosch I implemented local FOLLOW sets that are combined
        at run-time upon error to avoid overhead during parsing.
        """
        
        return self.combineFollows(False)

        
    def computeContextSensitiveRuleFOLLOW(self):
        """
        Compute the context-sensitive FOLLOW set for current rule.
        This is set of token types that can follow a specific rule
        reference given a specific call chain.  You get the set of
        viable tokens that can possibly come next (lookahead depth 1)
        given the current call chain.  Contrast this with the
        definition of plain FOLLOW for rule r:

         FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}

        where x in T* and alpha, beta in V*; T is set of terminals and
        V is the set of terminals and nonterminals.  In other words,
        FOLLOW(r) is the set of all tokens that can possibly follow
        references to r in *any* sentential form (context).  At
        runtime, however, we know precisely which context applies as
        we have the call chain.  We may compute the exact (rather
        than covering superset) set of following tokens.

        For example, consider grammar:

        stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
             | "return" expr '.'
             ;
        expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
        atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
             | '(' expr ')'
             ;

        The FOLLOW sets are all inclusive whereas context-sensitive
        FOLLOW sets are precisely what could follow a rule reference.
        For input input "i=(3);", here is the derivation:

        stat => ID '=' expr ';'
             => ID '=' atom ('+' atom)* ';'
             => ID '=' '(' expr ')' ('+' atom)* ';'
             => ID '=' '(' atom ')' ('+' atom)* ';'
             => ID '=' '(' INT ')' ('+' atom)* ';'
             => ID '=' '(' INT ')' ';'

        At the "3" token, you'd have a call chain of

          stat -> expr -> atom -> expr -> atom

        What can follow that specific nested ref to atom?  Exactly ')'
        as you can see by looking at the derivation of this specific
        input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.

        You want the exact viable token set when recovering from a
        token mismatch.  Upon token mismatch, if LA(1) is member of
        the viable next token set, then you know there is most likely
        a missing token in the input stream.  "Insert" one by just not
        throwing an exception.
        """

        return self.combineFollows(True)


    def combineFollows(self, exact):
        followSet = set()
        for localFollowSet in reversed(self.following):
            followSet |= localFollowSet
            if exact and EOR_TOKEN_TYPE not in localFollowSet:
                break

        followSet -= set([EOR_TOKEN_TYPE])
        return followSet


    def recoverFromMismatchedToken(self, input, e, ttype, follow):
        """Attempt to recover from a single missing or extra token.

        EXTRA TOKEN

        LA(1) is not what we are looking for.  If LA(2) has the right token,
        however, then assume LA(1) is some extra spurious token.  Delete it
        and LA(2) as if we were doing a normal match(), which advances the
        input.

        MISSING TOKEN

        If current token is consistent with what could come after
        ttype then it is ok to "insert" the missing token, else throw
        exception For example, Input "i=(3;" is clearly missing the
        ')'.  When the parser returns from the nested call to expr, it
        will have call chain:

          stat -> expr -> atom

        and it will be trying to match the ')' at this point in the
        derivation:

             => ID '=' '(' INT ')' ('+' atom)* ';'
                                ^
        match() will see that ';' doesn't match ')' and report a
        mismatched token error.  To recover, it sees that LA(1)==';'
        is in the set of tokens that can follow the ')' token
        reference in rule atom.  It can assume that you forgot the ')'.
        """
                                         
        # if next token is what we are looking for then "delete" this token
        if input.LA(2) == ttype:
            self.reportError(e)

            self.beginResync()
            input.consume() # simply delete extra token
            self.endResync()
            input.consume()  # move past ttype token as if all were ok
            return

        if not self.recoverFromMismatchedElement(input, e, follow):
            raise e



    def recoverFromMismatchedSet(self, input, e, follow):
        # TODO do single token deletion like above for Token mismatch
        if not self.recoverFromMismatchedElement(input, e, follow):
            raise e


    def recoverFromMismatchedElement(self, input, e, follow):
        """
        This code is factored out from mismatched token and mismatched set
        recovery.  It handles "single token insertion" error recovery for
        both.  No tokens are consumed to recover from insertions.  Return
        true if recovery was possible else return false.
        """
        
        if follow is None:
            # we have no information about the follow; we can only consume
            # a single token and hope for the best
            return False

        # compute what can follow this grammar element reference
        if EOR_TOKEN_TYPE in follow:
            viableTokensFollowingThisRule = \
                self.computeContextSensitiveRuleFOLLOW()
            
            follow = (follow | viableTokensFollowingThisRule) \
                     - set([EOR_TOKEN_TYPE])

        # if current token is consistent with what could come after set
        # then it is ok to "insert" the missing token, else throw exception
        if input.LA(1) in follow:
            self.reportError(e)
            return True

        # nothing to do; throw exception
        return False


    def consumeUntil(self, input, tokenTypes):
        """
        Consume tokens until one matches the given token or token set

        tokenTypes can be a single token type or a set of token types
        
        """
        
        if not isinstance(tokenTypes, (set, frozenset)):
            tokenTypes = frozenset([tokenTypes])

        ttype = input.LA(1)
        while ttype != EOF and ttype not in tokenTypes:
            input.consume()
            ttype = input.LA(1)


    def getRuleInvocationStack(self):
        """
        Return List<String> of the rules in your parser instance
        leading up to a call to this method.  You could override if
        you want more details such as the file/line info of where
        in the parser java code a rule is invoked.

        This is very useful for error messages and for context-sensitive
        error recovery.

        You must be careful, if you subclass a generated recognizers.
        The default implementation will only search the module of self
        for rules, but the subclass will not contain any rules.
        You probably want to override this method to look like

        def getRuleInvocationStack(self):
            return self._getRuleInvocationStack(<class>.__module__)

        where <class> is the class of the generated recognizer, e.g.
        the superclass of self.
	"""

        return self._getRuleInvocationStack(self.__module__)


    def _getRuleInvocationStack(cls, module):
        """
        A more general version of getRuleInvocationStack where you can
        pass in, for example, a RecognitionException to get it's rule
        stack trace.  This routine is shared with all recognizers, hence,
        static.

        TODO: move to a utility class or something; weird having lexer call
        this
        """

        # mmmhhh,... perhaps look at the first argument
        # (f_locals[co_varnames[0]]?) and test if it's a (sub)class of
        # requested recognizer...
        
        rules = []
        for frame in reversed(inspect.stack()):
            code = frame[0].f_code
            codeMod = inspect.getmodule(code)
            if codeMod is None:
                continue

            # skip frames not in requested module
            if codeMod.__name__ != module:
                continue

            # skip some unwanted names
            if code.co_name in ('nextToken', '<module>'):
                continue

            rules.append(code.co_name)

        return rules
        
    _getRuleInvocationStack = classmethod(_getRuleInvocationStack)
    

    def getBacktrackingLevel(self):
        return self.backtracking


    def getGrammarFileName(self):
        """For debugging and other purposes, might want the grammar name.
        
        Have ANTLR generate an implementation for this method.
        """

        return None


    def toStrings(self, tokens):
        """A convenience method for use most often with template rewrites.

        Convert a List<Token> to List<String>
        """

        if tokens is None:
            return None

        return [token.text for token in tokens]


    def getRuleMemoization(self, ruleIndex, ruleStartIndex):
        """
        Given a rule number and a start token index number, return
        MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
        start index.  If this rule has parsed input starting from the
        start index before, then return where the rule stopped parsing.
        It returns the index of the last token matched by the rule.

        For now we use a hashtable and just the slow Object-based one.
        Later, we can make a special one for ints and also one that
        tosses out data after we commit past input position i.
	"""
        
        if ruleIndex not in self.ruleMemo:
            self.ruleMemo[ruleIndex] = {}
		
        stopIndex = self.ruleMemo[ruleIndex].get(ruleStartIndex, None)
        if stopIndex is None:
            return self.MEMO_RULE_UNKNOWN

        return stopIndex


    def alreadyParsedRule(self, input, ruleIndex):
        """
        Has this rule already parsed input at the current index in the
        input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
        If we attempted but failed to parse properly before, return
        MEMO_RULE_FAILED.

        This method has a side-effect: if we have seen this input for
        this rule and successfully parsed before, then seek ahead to
        1 past the stop token matched for this rule last time.
        """
        
        stopIndex = self.getRuleMemoization(ruleIndex, input.index())
        if stopIndex == self.MEMO_RULE_UNKNOWN:
            return False

        if stopIndex == self.MEMO_RULE_FAILED:
            self.failed = True

        else:
            input.seek(stopIndex + 1)

        return True


    def memoize(self, input, ruleIndex, ruleStartIndex):
        """
        Record whether or not this rule parsed the input at this position
	successfully.
	"""

        if self.failed:
            stopTokenIndex = self.MEMO_RULE_FAILED
        else:
            stopTokenIndex = input.index() - 1
        
        if ruleIndex in self.ruleMemo:
            self.ruleMemo[ruleIndex][ruleStartIndex] = stopTokenIndex


    def traceIn(self, ruleName, ruleIndex, inputSymbol):
        sys.stdout.write("enter %s %s" % (ruleName, inputSymbol))
        
        if self.failed:
            sys.stdout.write(" failed=%s" % self.failed)

        if self.backtracking > 0:
            sys.stdout.write(" backtracking=%s" % self.backtracking)

        sys.stdout.write('\n')


    def traceOut(self, ruleName, ruleIndex, inputSymbol):
        sys.stdout.write("exit %s %s" % (ruleName, inputSymbol))
        
        if self.failed:
            sys.stdout.write(" failed=%s" % self.failed)

        if self.backtracking > 0:
            sys.stdout.write(" backtracking=%s" % self.backtracking)

        sys.stdout.write('\n')



class TokenSource(object):
    """
    @brief Abstract baseclass for token producers.
    
    A source of tokens must provide a sequence of tokens via nextToken()
    and also must reveal it's source of characters; CommonToken's text is
    computed from a CharStream; it only store indices into the char stream.

    Errors from the lexer are never passed to the parser.  Either you want
    to keep going or you do not upon token recognition error.  If you do not
    want to continue lexing then you do not want to continue parsing.  Just
    throw an exception not under RecognitionException and Java will naturally
    toss you all the way out of the recognizers.  If you want to continue
    lexing then you should not throw an exception to the parser--it has already
    requested a token.  Keep lexing until you get a valid one.  Just report
    errors and keep going, looking for a valid token.
    """
    
    def nextToken(self):
        """Return a Token object from your input stream (usually a CharStream).
        
        Do not fail/return upon lexing error; keep chewing on the characters
        until you get a good one; errors are not passed through to the parser.
        """

        raise NotImplementedError
    

class Lexer(BaseRecognizer, TokenSource):
    """
    @brief Baseclass for generated lexer classes.
    
    A lexer is recognizer that draws input symbols from a character stream.
    lexer grammars result in a subclass of this object. A Lexer object
    uses simplified match() and error recovery mechanisms in the interest
    of speed.
    """

    def __init__(self, input):
        BaseRecognizer.__init__(self)
        TokenSource.__init__(self)
        
        # Where is the lexer drawing characters from?
        self.input = input

        # The goal of all lexer rules/methods is to create a token object.
	# This is an instance variable as multiple rules may collaborate to
	# create a single token.  nextToken will return this object after
	# matching lexer rule(s).  If you subclass to allow multiple token
	# emissions, then set this to the last token to be matched or
	# something nonnull so that the auto token emit mechanism will not
	# emit another token.
        self.token = None

	# What character index in the stream did the current token start at?
	# Needed, for example, to get the text for current token.  Set at
	# the start of nextToken.
        self.tokenStartCharIndex = -1

        # The line on which the first character of the token resides
        self.tokenStartLine = -1

        # The character position of first character within the line
        self.tokenStartCharPositionInLine = -1

        # The channel number for the current token
        self.channel = DEFAULT_CHANNEL

        # The token type for the current token
        self.type = INVALID_TOKEN_TYPE
        
        # You can set the text for the current token to override what is in
	# the input char buffer.  Use setText() or can set this instance var.
        self._text = None


    def reset(self):
        BaseRecognizer.reset(self) # reset all recognizer state variables

        # wack Lexer state variables
        self.token = None
        self.type = INVALID_TOKEN_TYPE
        self.channel = DEFAULT_CHANNEL
        self.tokenStartCharIndex = -1
        self.tokenStartLine = -1
        self.tokenStartCharPositionInLine = -1
        self._text = None
        if self.input is not None:
            self.input.seek(0) # rewind the input


    def nextToken(self):
        """
        Return a token from this source; i.e., match a token on the char
	stream.
	"""
        
        while 1:
            self.token = None
            self.channel = DEFAULT_CHANNEL
            self.tokenStartCharIndex = self.input.index()
            self.tokenStartCharPositionInLine = self.input.charPositionInLine
            self.tokenStartLine = self.input.line
            self._text = None
            if self.input.LA(1) == EOF:
                return EOF_TOKEN

            try:
                self.mTokens()
                
                if self.token is None:
                    self.emit()
                    
                elif self.token == SKIP_TOKEN:
                    continue

                return self.token

            except RecognitionException, re:
                self.reportError(re)
                self.recover(re)


    def skip(self):
        """
	Instruct the lexer to skip creating a token for current lexer rule
	and look for another token.  nextToken() knows to keep looking when
	a lexer rule finishes with token set to SKIP_TOKEN.  Recall that
	if token==null at end of any token rule, it creates one for you
	and emits it.
	"""
        
        self.token = SKIP_TOKEN


    def mTokens(self):
        """This is the lexer entry point that sets instance var 'token'"""

        # abstract method
        raise NotImplementedError
    

    def setCharStream(self, input):
        """Set the char stream and reset the lexer"""
        self.input = None
        self.reset()
        self.input = input


    def emit(self, token=None):
        """
        The standard method called to automatically emit a token at the
	outermost lexical rule.  The token object should point into the
	char buffer start..stop.  If there is a text override in 'text',
	use that to set the token's text.
	"""

        if token is None:
            token = CommonToken(
                input=self.input,
                type=self.type,
                channel=self.channel,
                start=self.tokenStartCharIndex,
                stop=self.getCharIndex()-1
                )
            token.line = self.tokenStartLine
            token.text = self.text
            token.charPositionInLine = self.tokenStartCharPositionInLine

        self.token = token
        
        return token


    def match(self, s):
        if isinstance(s, basestring):
            i = 0
            while i < len(s):
                if self.input.LA(1) != s[i]:
                    if self.backtracking > 0:
                        self.failed = True
                        return

                    mte = MismatchedTokenException(s[i], self.input)
                    self.recover(mte)
                    raise mte

                i += 1
                self.input.consume()
                self.failed = False

        else:
            if self.input.LA(1) != s:
                if self.backtracking > 0:
                    self.failed = True
                    return

                mte = MismatchedTokenException(s, self.input)
                self.recover(mte)
                raise mte
        
            self.input.consume()
            self.failed = False
            

    def matchAny(self):
        self.input.consume()


    def matchRange(self, a, b):
        if self.input.LA(1) < a or self.input.LA(1) > b:
            if self.backtracking > 0:
                self.failed = True
                return

            mre = MismatchedRangeException(a, b, self.input)
            self.recover(mre)
            raise mre

        self.input.consume()
        self.failed = False


    def getLine(self):
        return self.input.line


    def getCharPositionInLine(self):
        return self.input.charPositionInLine


    def getCharIndex(self):
        """What is the index of the current character of lookahead?"""
        
        return self.input.index()


    def getText(self):
        """
        Return the text matched so far for the current token or any
        text override.
        """
        if self._text is not None:
            return self._text
        
        return self.input.substring(
            self.tokenStartCharIndex,
            self.getCharIndex()-1
            )


    def setText(self, text):
        """
        Set the complete text of this token; it wipes any previous
	changes to the text.
	"""
        self._text = text


    text = property(getText, setText)


    def reportError(self, e):
        ## TODO: not thought about recovery in lexer yet.

        ## # if we've already reported an error and have not matched a token
        ## # yet successfully, don't report any errors.
        ## if self.errorRecovery:
        ##     #System.err.print("[SPURIOUS] ");
        ##     return;
        ## 
        ## self.errorRecovery = True

        self.displayRecognitionError(self.tokenNames, e)


    def getErrorMessage(self, e, tokenNames):
        msg = None
        
        if isinstance(e, MismatchedTokenException):
            msg = "mismatched character " \
                  + self.getCharErrorDisplay(e.c) \
                  + " expecting " \
                  + self.getCharErrorDisplay(e.expecting)

        elif isinstance(e, NoViableAltException):
            msg = "no viable alternative at character " \
                  + self.getCharErrorDisplay(e.c)

        elif isinstance(e, EarlyExitException):
            msg = "required (...)+ loop did not match anything at character " \
                  + self.getCharErrorDisplay(e.c)
            
        elif isinstance(e, MismatchedSetException):
            msg = "mismatched character " \
                  + self.getCharErrorDisplay(e.c) \
                  + " expecting set " \
                  + repr(e.expecting)

        elif isinstance(e, MismatchedNotSetException):
            msg = "mismatched character " \
                  + self.getCharErrorDisplay(e.c) \
                  + " expecting set " \
                  + repr(e.expecting)

        elif isinstance(e, MismatchedRangeException):
            msg = "mismatched character " \
                  + self.getCharErrorDisplay(e.c) \
                  + " expecting set " \
                  + self.getCharErrorDisplay(e.a) \
                  + ".." \
                  + self.getCharErrorDisplay(e.b)

        else:
            msg = BaseRecognizer.getErrorMessage(self, e, tokenNames)

        return msg


    def getCharErrorDisplay(self, c):
        if c == EOF:
            c = '<EOF>'
        return repr(c)


    def recover(self, re):
        """
        Lexers can normally match any char in it's vocabulary after matching
	a token, so do the easy thing and just kill a character and hope
	it all works out.  You can instead use the rule invocation stack
	to do sophisticated error recovery if you are in a fragment rule.
	"""

        self.input.consume()


    def traceIn(self, ruleName, ruleIndex):
        inputSymbol = "%s line=%d:%s" % (self.input.LT(1),
                                         self.getLine(),
                                         self.getCharPositionInLine()
                                         )
        
        BaseRecognizer.traceIn(self, ruleName, ruleIndex, inputSymbol)


    def traceOut(self, ruleName, ruleIndex):
        inputSymbol = "%s line=%d:%s" % (self.input.LT(1),
                                         self.getLine(),
                                         self.getCharPositionInLine()
                                         )

        BaseRecognizer.traceOut(self, ruleName, ruleIndex, inputSymbol)



class Parser(BaseRecognizer):
    """
    @brief Baseclass for generated parser classes.
    """
    
    def __init__(self, lexer):
        BaseRecognizer.__init__(self)

        self.setTokenStream(lexer)


    def reset(self):
        BaseRecognizer.reset(self) # reset all recognizer state variables
        if self.input is not None:
            self.input.seek(0) # rewind the input


    def setTokenStream(self, input):
        """Set the token stream and reset the parser"""
        
        self.input = None
        self.reset()
        self.input = input


    def getTokenStream(self):
        return self.input


    def traceIn(self, ruleName, ruleIndex):
        BaseRecognizer.traceIn(self, ruleName, ruleIndex, self.input.LT(1))


    def traceOut(self, ruleName, ruleIndex):
        BaseRecognizer.traceOut(self, ruleName, ruleIndex, self.input.LT(1))

