Program ::= ClassBlock;
ClassBlock ::= DeclStmt:Stmt* Method*;
abstract Stmt;
DeclStmt ::= Type:AccessVal <ID:String> Dims* [Value:Exp];
Method ::= MethodHeader MethodBlock;
MethodHeader ::= ReturnType:AccessVal <Name:String> Args*;
Args ::= Type <Name:String>;
Type:AccessVal ::= <Name:String>;
MethodBlock ::=Stmt*;
AssignStmt:ExpStmt ::=  <ID:String> Value:Exp;
ExpStmt:Stmt ::= Exp;
IDUse:Exp ::= <ID:String>;
Dims ::= [Exp];

abstract UnaryExp:Exp ::= Operand:Exp;
PreIncExp:UnaryExp;
PreDecExp:UnaryExp;
MinusExp:UnaryExp;
PlusExp:UnaryExp;
NegExp:UnaryExp;

abstract BinaryExp:Exp ::= LeftOp:Exp RightOp:Exp;
abstract ArithExp:BinaryExp;
abstract MultiplicativeExp:ArithExp;
MulExp:MultiplicativeExp;
DivExp:MultiplicativeExp;
ModExp:MultiplicativeExp;
abstract AdditiveExp:BinaryExp;
AddExp:AdditiveExp;
SubExp:AdditiveExp;

//Add more BinaryExp : Shift, Logical

abstract RelationalExp:BinaryExp;
LTExp : RelationalExp ;                                                       
GTExp : RelationalExp ;                                                       
LEExp : RelationalExp ;                                                       
GEExp : RelationalExp ;  
abstract EqualityExp : RelationalExp;                                         
EQExp : EqualityExp ;                                                         
NEExp : EqualityExp ;

Modifiers ::= Modifier*;                                                        
Modifier ::= <ID:String>;     
  
Identifier:AccessVal ::= <Name:String>;

WhileStmt:Stmt ::= Condition:Exp LoopBody;
LoopBody:Stmt ::= Stmt*;
IfElseStmt:Stmt ::= Condition:Exp IfBody:Stmt [ElseBody:Stmt];
IfBody:Stmt ::= Stmt*;
ElseBody:Stmt ::= Stmt*;
abstract Exp;

abstract AccessVal:Exp;
abstract MethodCall:Exp;
BuiltinMethodCall:MethodCall ::= BuiltinMethodName:MethodId Argument:Exp*;
abstract MethodId:AccessVal ::= <Name:String>;
UserDefMethodCall:MethodCall ::= UserDefMethodName:MethodId Argument:Exp*;


